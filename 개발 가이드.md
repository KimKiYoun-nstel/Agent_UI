좋아. 지금 **UI_v1.2**를 뜯어봤다. 딱 걸린 부분 하나.

## 결론 (원인)

`Services/CborMapCodec.cs`에서 **`target`을 문자열로 인코딩**하고 있어.
서버는 `target`을 **객체(Map)** 로 가정하고 `target.value("kind", ...)`처럼 접근하기 때문에, 문자열이 오면 네가 본 것처럼:

```
json.exception.type_error.306 cannot use value() with string
```

이 터진다.

* 현재 UI_v1.2 코드 (문제 지점):

  ```csharp
  // Services/CborMapCodec.cs
  w.WriteTextString("target");
  w.WriteTextString(req.Target ?? "");
  ```
* 서버 기대:

  ```json
  "target": { "kind": "agent" }   // hello
  // 또는
  "target": { "kind": "writer", "topic":"...", "type":"..." }  // create/write 등
  ```

---

## 수정 가이드 (정확한 패치)

### 1) `Services/Frames.cs` 수정 — Target 확장 필드 추가

**목적:** `target`에 `{ kind: ..., ...추가필드 }` 형태로 내보낼 수 있게.

* 파일 열기: `Services/Frames.cs`
* `Req` 클래스에 아래 필드 1개 **추가**:

```csharp
public System.Collections.Generic.Dictionary<string, object?>? TargetExtra { get; init; }
```

완성 예:

```csharp
public sealed class Req
{
    public required string Op { get; init; }
    public required string Target { get; init; } // "agent","participant","writer"...
    public System.Collections.Generic.Dictionary<string, object?>? TargetExtra { get; init; } // ★ 추가
    public object? Args { get; init; }
    public object? Data { get; init; }
    public int Proto { get; init; } = 1;
}
```

---

### 2) `Services/CborMapCodec.cs` 수정 — target을 Map으로 인코딩

**목적:** 항상 `{"kind": "<Target>", ...TargetExtra}` 로 인코딩.

* 파일 열기: `Services/CborMapCodec.cs`
* `EncodeReq` 내 **target** 부분을 아래로 교체:

```csharp
w.WriteTextString("target");
if (req.TargetExtra is { } extra && extra.Count > 0)
{
    w.WriteStartMap(1 + extra.Count);
    w.WriteTextString("kind"); w.WriteTextString(req.Target ?? "");
    foreach (var kv in extra)
    {
        w.WriteTextString(kv.Key);
        WriteJsonAsCbor(w, kv.Value);
    }
    w.WriteEndMap();
}
else
{
    w.WriteStartMap(1);
    w.WriteTextString("kind"); w.WriteTextString(req.Target ?? "");
    w.WriteEndMap();
}
```

> 나머지 `op/args/data/proto` 인코딩은 그대로 두면 된다. 디코딩(`TryDecode`)은 이미 Lax 모드로 잘 받아주고 있음.

---

### 3) hello 전송 코드 점검 (ViewModel에서 만드는 곳)

**목적:** TargetExtra 없어도 `{ "kind":"agent" }`가 나간다.

* 현재 너의 3단계 hello 전송 코드에서 `Req` 생성 시 다음처럼 둬도 OK:

```csharp
var helloReq = new Req {
    Op = "hello",
    Target = "agent",
    // TargetExtra = null, // 생략 가능 → {"kind":"agent"}로 인코딩됨
    Args = null,
    Data = null
};
```

* 이후 4단계부터는 예를 들어 writer 생성 같은 경우:

```csharp
var createWriterReq = new Req {
    Op = "create",
    Target = "writer",
    TargetExtra = new() { ["topic"] = "MyTopic", ["type"] = "C_MyType" },
    Args = new { participant = "P1", qos = "Lib::Profile" },
    Data = null
};
```

---

## 확인 절차 (테스트 플로우)

1. 위 두 파일 수정 후 빌드.
2. UI 실행 → **Connect** 클릭.
3. Gateway 로그 확인:

   * `[IPC] on_request ...` 뒤에 더 이상 `json.exception.type_error.306`가 나오지 않아야 함.
   * `cmd exec` → `process_request` → **hello 처리**로 들어가서 **RSP**를 돌려줄 것.
4. UI **Messages** 탭:

   * **OUT hello** 1줄,
   * **IN hello** 1줄(RSP, `ok=true/false`)이 찍히는지 확인.

---

## 추가 팁 (문제 재발 방지)

* `CborMapCodec.EncodeReq`에서 키 오탈자 주의:
  `op / target / args / data / proto` (전부 소문자)
* 추후 단계에서 `write`/`create` 등도 모두 **target Map** 패턴을 재사용:

  * writer 관련 동작: `Target="writer", TargetExtra["topic"], ["type"]`
  * participant/publisher/subscriber도 동일하게 `kind` 값만 바꿔서 확장.

---

## 왜 이게 정확하냐?

* 서버 코드가 `target`을 **json object**로 가정하고 `value("kind", ...)`, `value("topic", ...)`를 호출함.
* 문자열이 오면 `value()` 호출 시 **type_error.306**가 발생(네가 본 로그 그대로).

---

필요하면 내가 **패치된 전체 파일 버전**(`Frames.cs`, `CborMapCodec.cs`)을 한 번에 붙여도 컴파일 깨지지 않게 정리해서 줄게.
우선 위 두 군데만 고치고 돌려보면 바로 응답 들어올 거야.
