좋아. 속도 내서 5·6·7단계를 한 번에 붙일게.
핵심 원칙은 “**QT UI와 동일한 계약**” — 특히 `write` 시 **data는 `{ "text":"<JSON 문자열>" }`** 이다.
아래는 **파일/삽입 위치가 분명한 튜토리얼**이야. 그대로 따라가면 바로 돌아간다.

---

# 5단계 — Publish / EVT 수신

## 목표

* `op:"write"` 요청으로 **JSON payload 전송**
* 서버의 `EVT(evt:"data")` 수신 → **Messages/Log 반영**

## 변경 요약

* `MainViewModel.cs` : `PublishCommand` 추가, `EventReceived` 핸들러 강화
* **주의**: `target`은 Map, `args`는 **Qt와 동일**(writer=publisher 참조), `data.text`는 **압축 JSON 문자열**

---

### 5-1) ViewModel: JSON 파서 & 문자열화 유틸

`MainViewModel.cs` 최상단 private 유틸 추가:

```csharp
private static object ParseJsonOrThrow(string text)
{
    try
    {
        return System.Text.Json.JsonSerializer.Deserialize<object>(text)
               ?? throw new InvalidOperationException("빈 JSON");
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException($"Payload JSON 오류: {ex.Message}");
    }
}

private static string ToCompactJsonString(object node)
    => System.Text.Json.JsonSerializer.Serialize(node,
        new System.Text.Json.JsonSerializerOptions{ WriteIndented = false });
```

---

### 5-2) ViewModel: PublishCommand 추가

`MainViewModel` 생성자에서 등록하고, 본문 구현:

```csharp
public RelayCommand PublishCommand { get; }

PublishCommand = new RelayCommand(async () =>
{
    try
    {
        // 필수 입력 검증 (QT 동작과 동일)
        Require(DomainId >= 0,             "Domain 필요");
        Require(!IsNullOrWhite(PublisherName), "Publisher 이름 필요");   // writer는 publisher 기반
        Require(!IsNullOrWhite(TopicName), "Topic 필요");
        Require(!IsNullOrWhite(TypeName),  "Type 필요(C_*)");
        Require(!IsNullOrWhite(PayloadText), "Payload 필요");

        // 1) JSON 파싱 후, "압축 문자열"로 변환
        var jsonObj = ParseJsonOrThrow(PayloadText);
        var compact = ToCompactJsonString(jsonObj);

        // 2) write REQ (QT와 동일한 키)
        var qos = BuildQos(); // 4단계에서 만든 유틸
        var targetExtra = new Dictionary<string, object?> {
            ["topic"] = TopicName, ["type"] = TypeName
        };
        var args = new { domain = DomainId, publisher = PublisherName, qos };
        var data = new { text = compact }; // ★ Gateway 계약: data.text = JSON 문자열

        var req = new Req {
            Op = "write",
            Target = "writer",
            TargetExtra = targetExtra,
            Args = args,
            Data = data
        };

        AddOutTraffic("write", new { target = targetExtra, args, data });

        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
        var rsp = await _agent.RequestAsync(req, cts.Token);

        AddInTraffic("write", new { ok = rsp.Ok, action = rsp.Action, data = rsp.Data, err = rsp.Err });
        Status = rsp.Ok ? "Write OK" : $"Write failed: {rsp.Err ?? "unknown"}";
    }
    catch (OperationCanceledException) { Status = "Write timeout"; Log("Write timeout"); }
    catch (Exception ex)               { Status = "Write error";   Log($"Write error: {ex.Message}"); }
});
```

---

### 5-3) EVT 수신 반영(데이터 이벤트)

3.5단계에서 연결한 `AgentClient.EventReceived` 콜백 내부를 강화:

```csharp
_agent.EventReceived += evt =>
{
    try
    {
        // evt.Kind == "data"일 때 표시 강화
        AddInTraffic($"evt.{evt.Kind}", evt.Data);

        // 선택: display.text가 있으면 페이로드 창 갱신(미러링)
        if (evt.Kind == "data")
        {
            var json = System.Text.Json.JsonSerializer.Serialize(evt.Data);
            Log($"EVT data: {json}");
        }
    }
    catch (Exception ex)
    {
        Log($"EVT 처리 오류: {ex.Message}");
    }
};
```

> 이제 **Create Writer → Publish** 하면 Messages에 OUT `write`, IN `evt.data`가 보여야 한다.

---

# 6단계 — Sample JSON 자동 생성

## 목표

* 타입 선택 시(또는 “Sample JSON” 버튼) **예제 JSON 자동 채움**
* 소스: `config/generated/*.xml` (1단계에서 만든 타입 레지스트리 활용)

## 변경 요약

* `Services/SampleJsonBuilder.cs` 추가 (타입스키마 → 샘플 JSON)
* `MainViewModel.cs`에 `SampleJsonCommand` 추가

> 아래 코드는 **간결한 규칙**으로 충분히 쓸 만한 샘플을 만든다.

---

### 6-1) SampleJsonBuilder 추가

`Services/SampleJsonBuilder.cs` 새 파일:

```csharp
using System.Collections.Generic;

namespace Agent.UI.Wpf.Services
{
    public interface ITypeSchemaProvider
    {
        // 1단계에서 구축한 타입 레지스트리에서 스키마를 제공한다고 가정
        TypeSchema? GetSchema(string typeName); // "C_Foo"
    }

    public sealed class TypeSchema
    {
        public string Name { get; init; } = "";
        public List<Field> Fields { get; init; } = new();
        public sealed class Field
        {
            public string Name { get; init; } = "";
            public string Kind { get; init; } = "";  // "int","double","string","bool","enum","array","struct"
            public string? Type { get; init; }       // struct/enum/array elem type
            public bool IsArray => Kind == "array";
            public List<string>? EnumValues { get; init; }
        }
    }

    public sealed class SampleJsonBuilder
    {
        private readonly ITypeSchemaProvider _types;
        public SampleJsonBuilder(ITypeSchemaProvider types) => _types = types;

        public object BuildSample(string typeName)
        {
            var schema = _types.GetSchema(typeName)
                        ?? throw new System.InvalidOperationException($"알 수 없는 타입: {typeName}");
            var obj = new Dictionary<string, object?>();
            foreach (var f in schema.Fields)
            {
                obj[f.Name] = SampleForField(f);
            }
            return obj;
        }

        private object? SampleForField(TypeSchema.Field f)
        {
            switch (f.Kind)
            {
                case "int":    return 0;
                case "double": return 0.0;
                case "bool":   return false;
                case "string": return "";
                case "enum":   return (f.EnumValues?.Count ?? 0) > 0 ? f.EnumValues![0] : "";
                case "struct":
                    return f.Type is { } s ? BuildSample(s) : new Dictionary<string, object?>();
                case "array":
                    // 최소 1개 샘플
                    var elem = new TypeSchema.Field { Name = "item", Kind = BasicKindFrom(f.Type), Type = f.Type };
                    return new List<object?> { SampleForField(elem) };
                default:
                    return null;
            }
        }

        // 간단 매핑(필요시 확장)
        private static string BasicKindFrom(string? type)
        {
            if (type is null) return "string";
            var t = type.ToLowerInvariant();
            if (t is "int" or "int32" or "int64") return "int";
            if (t is "double" or "float")         return "double";
            if (t is "bool")                      return "bool";
            if (t.StartsWith("c_"))               return "struct";
            return "string";
        }
    }
}
```

> `ITypeSchemaProvider`는 1단계에서 XML 파서가 만들어둔 타입 정보에서 구현하면 된다(이미 레지스트리 있으면 거기에서 꺼내기).

---

### 6-2) ViewModel: SampleJsonCommand

`MainViewModel.cs`에 추가:

```csharp
public RelayCommand SampleJsonCommand { get; }

private readonly SampleJsonBuilder _sampleBuilder; // DI 또는 생성자에서 초기화

SampleJsonCommand = new RelayCommand(() =>
{
    try
    {
        Require(!IsNullOrWhite(TypeName), "Type 필요");
        var sample = _sampleBuilder.BuildSample(TypeName);
        PayloadText = System.Text.Json.JsonSerializer.Serialize(sample, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        Status = "Sample JSON generated";
    }
    catch (Exception ex)
    {
        Status = "Sample JSON error";
        Log($"Sample JSON error: {ex.Message}");
    }
});
```

> XAML의 “Sample JSON” 버튼에 `Command="{Binding SampleJsonCommand}"`.

---

# 7단계 — Open Form (동적 입력 폼 v1)

## 목표

* 타입 스키마 기반으로 **입력 폼을 동적으로 생성**
* 사용자가 폼에 입력 → **JSON 생성** → Payload에 반영

## 변경 요약

* `Views/PayloadFormWindow.xaml` + `ViewModels/PayloadFormViewModel.cs` 추가
* `MainViewModel`에 `OpenFormCommand` 추가

> v1은 **실용적인 최소치**: 스칼라(TextBox/CheckBox), enum(ComboBox), 배열(간단 Add/Remove), 중첩 struct(Expander).

---

### 7-1) 뷰모델: FieldVM 트리

`ViewModels/PayloadFormViewModel.cs`:

```csharp
using System.Collections.ObjectModel;
using System.Linq;

namespace Agent.UI.Wpf.ViewModels
{
    public sealed class FieldVm : ObservableObject
    {
        public string Name { get; }
        public string Kind { get; }     // "string","int","double","bool","enum","array","struct"
        public ObservableCollection<string>? EnumValues { get; }
        public ObservableCollection<FieldVm>? Children { get; }   // struct/array elem
        private object? _value;
        public object? Value { get => _value; set => SetProperty(ref _value, value); }

        public FieldVm(string name, string kind,
                       ObservableCollection<string>? enumValues = null,
                       ObservableCollection<FieldVm>? children = null)
        {
            Name = name; Kind = kind; EnumValues = enumValues; Children = children;
        }
    }

    public sealed class PayloadFormViewModel : ObservableObject
    {
        public ObservableCollection<FieldVm> Fields { get; } = new();

        public PayloadFormViewModel(TypeSchema schema, SampleJsonBuilder helper)
        {
            // schema → Fields 변환(간단 구현)
            foreach (var f in schema.Fields)
                Fields.Add(CreateVm(f));
        }

        private FieldVm CreateVm(TypeSchema.Field f)
        {
            switch (f.Kind)
            {
                case "enum":
                    return new FieldVm(f.Name, "enum",
                        enumValues: new ObservableCollection<string>(f.EnumValues ?? new()));
                case "struct":
                    var s = AppServices.Types.GetSchema(f.Type!); // 전역 접근자 or DI
                    return new FieldVm(f.Name, "struct",
                        children: new ObservableCollection<FieldVm>(s!.Fields.Select(CreateVm)));
                case "array":
                    // v1: 단일 원소만 편집 → Publish 시 반복 사용
                    return new FieldVm(f.Name, "array",
                        children: new ObservableCollection<FieldVm>{ CreateVm(new TypeSchema.Field { Name="item", Kind=Basic(f.Type), Type=f.Type }) });
                default:
                    return new FieldVm(f.Name, Basic(f.Kind));
            }

            static string Basic(string? k)
            {
                k = (k ?? "").ToLowerInvariant();
                return k switch
                {
                    "int" or "int32" or "int64" => "int",
                    "double" or "float" => "double",
                    "bool" => "bool",
                    "string" => "string",
                    _ when k.StartsWith("c_") => "struct",
                    _ => "string"
                };
            }
        }

        public object ToJsonObject()
        {
            var dict = new Dictionary<string, object?>();
            foreach (var f in Fields) dict[f.Name] = ToJsonValue(f);
            return dict;
        }

        private object? ToJsonValue(FieldVm f)
        {
            return f.Kind switch
            {
                "int"    => TryInt(f.Value),
                "double" => TryDouble(f.Value),
                "bool"   => (f.Value as bool?) ?? false,
                "string" => f.Value?.ToString() ?? "",
                "enum"   => f.Value?.ToString() ?? (f.EnumValues?.FirstOrDefault() ?? ""),
                "struct" => f.Children is null ? null : f.Children.ToDictionary(c => c.Name, ToJsonValue),
                "array"  => f.Children is null ? new List<object?>() : new List<object?> { ToJsonValue(f.Children.First()) },
                _        => null
            };

            static object TryInt(object? v)    => int.TryParse(v?.ToString(), out var i) ? i : 0;
            static object TryDouble(object? v) => double.TryParse(v?.ToString(), out var d) ? d : 0.0;
        }
    }
}
```

---

### 7-2) 뷰: PayloadFormWindow

`Views/PayloadFormWindow.xaml` (간단 템플릿; v1):

```xml
<Window x:Class="Agent.UI.Wpf.Views.PayloadFormWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Payload Form" Height="520" Width="640">
  <ScrollViewer Margin="10">
    <ItemsControl ItemsSource="{Binding Fields}">
      <ItemsControl.ItemTemplate>
        <DataTemplate>
          <StackPanel Margin="0,4">
            <TextBlock Text="{Binding Name}" FontWeight="SemiBold"/>
            <ContentControl Content="{Binding}">
              <ContentControl.Style>
                <Style TargetType="ContentControl">
                  <Setter Property="ContentTemplate">
                    <Setter.Value>
                      <DataTemplate>
                        <TextBox Text="{Binding Value}" />
                      </DataTemplate>
                    </Setter.Value>
                  </Setter>
                  <Style.Triggers>
                    <DataTrigger Binding="{Binding Kind}" Value="bool">
                      <Setter Property="ContentTemplate">
                        <Setter.Value>
                          <DataTemplate><CheckBox IsChecked="{Binding Value}"/></DataTemplate>
                        </Setter.Value>
                      </Setter>
                    </DataTrigger>
                    <DataTrigger Binding="{Binding Kind}" Value="enum">
                      <Setter Property="ContentTemplate">
                        <Setter.Value>
                          <DataTemplate>
                            <ComboBox ItemsSource="{Binding EnumValues}" SelectedItem="{Binding Value, Mode=TwoWay}"/>
                          </DataTemplate>
                        </Setter.Value>
                      </Setter>
                    </DataTrigger>
                    <DataTrigger Binding="{Binding Kind}" Value="struct">
                      <Setter Property="ContentTemplate">
                        <Setter.Value>
                          <DataTemplate>
                            <Border BorderBrush="#DDD" BorderThickness="1" Padding="6" Margin="0,4,0,0">
                              <ItemsControl ItemsSource="{Binding Children}">
                                <ItemsControl.ItemTemplate>
                                  <DataTemplate>
                                    <StackPanel Margin="0,2">
                                      <TextBlock Text="{Binding Name}" />
                                      <TextBox Text="{Binding Value}" />
                                    </StackPanel>
                                  </DataTemplate>
                                </ItemsControl.ItemTemplate>
                              </ItemsControl>
                            </Border>
                          </DataTemplate>
                        </Setter.Value>
                      </Setter>
                    </DataTrigger>
                  </Style.Triggers>
                </Style>
              </ContentControl.Style>
            </ContentControl>
            <Separator/>
          </StackPanel>
        </DataTemplate>
      </ItemsControl.ItemTemplate>
    </ItemsControl>
  </ScrollViewer>
</Window>
```

코드비하인드(뷰모델 주입만):

```csharp
public partial class PayloadFormWindow : Window
{
    public PayloadFormWindow(object vm)
    {
        InitializeComponent();
        DataContext = vm;
    }
}
```

---

### 7-3) ViewModel: OpenFormCommand

`MainViewModel.cs`에 추가:

```csharp
public RelayCommand OpenFormCommand { get; }

OpenFormCommand = new RelayCommand(() =>
{
    try
    {
        Require(!IsNullOrWhite(TypeName), "Type 필요");
        var schema = _typeRegistry.GetSchema(TypeName)  // 1단계의 레지스트리(=ITypeSchemaProvider 구현)
                     ?? throw new InvalidOperationException($"알 수 없는 타입: {TypeName}");

        var vm = new Agent.UI.Wpf.ViewModels.PayloadFormViewModel(schema, _sampleBuilder);
        var win = new Agent.UI.Wpf.Views.PayloadFormWindow(vm);
        win.Owner = Application.Current.MainWindow;
        if (win.ShowDialog() == true) { /* v1에선 OK 버튼 없이 즉시 반영하게 했다면 생략 */ }

        // 폼 → JSON → PayloadText 반영
        var json = vm.ToJsonObject();
        PayloadText = System.Text.Json.JsonSerializer.Serialize(json, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        Status = "Form applied";
    }
    catch (Exception ex)
    {
        Status = "OpenForm error";
        Log($"OpenForm error: {ex.Message}");
    }
});
```

> 버튼은 XAML에서 `Command="{Binding OpenFormCommand}"`로 연결.

---

## 통합 테스트 체크리스트

1. **Connect → Handshake OK**
2. **Create participant → publisher → writer** (4단계 OK 상태 유지)
3. **Sample JSON** 클릭 → Payload가 예제로 채워지는지
4. **Open Form** → 값 입력 → **Payload** 갱신되는지
5. **Publish** → Messages OUT에 `write`, IN에 `evt.data` 들어오는지
6. 서버 로그에 예외 없이 처리, 토픽/타입 일치 확인

---

## 흔한 삑사리와 빠른 교정

* **write가 실패**: `data`가 `{text: "<문자열>"}`가 아닌 **객체 그대로** 갔을 때
  → `data = new { text = compact }`로 보냈는지 확인.
* **EVT가 안 보임**: `AgentClient.EventReceived`에서 `evt.Kind=="data"` 분기를 빼먹음
  → AddInTraffic에 그대로 찍어줘.
* **Sample JSON이 비정상**: 타입 스키마 매핑이 부정확
  → `TypeSchema.Field.Kind` 매핑 표를 한 번 더 손봐(특히 enum/array/struct).
* **Open Form 값 반영 안 됨**: `ToJsonObject()` 로직 누락/오탈자
  → 필드명과 대소문자, 배열 처리(최소 1개) 확인.

---

원하면 지금 너의 저장소 구조/클래스명에 맞춰 **정확한 네임스페이스·경로**까지 재매핑해서 델타 패치 형태로도 정리해줄게. 이대로 붙이면 5·6·7이 한 번에 살아난다.
