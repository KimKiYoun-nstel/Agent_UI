1단계: 설정 파일 파싱 기능 구현 (토픽 타입 목록 & QoS 프로필 목록)

1단계의 목표는 config 디렉터리의 XML 설정 파일들을 읽어들여 UI에 표시할 토픽 타입 목록과 QoS 프로필 목록을 동적으로 생성하는 것입니다. 기존 코드에서는 하드코딩된 예시 데이터(Lib::Profile_A, C_SampleType 등)를 사용하고 있으므로
GitHub
, 이를 실제 파일 파싱 결과로 대체해야 합니다. 별도의 토픽 전용 XML은 없으므로 generated 하위 폴더의 XML에서 타입 정보를 추출하고, qos 하위 폴더의 XML에서 QoS 프로필 이름을 수집합니다. 아래에 각 작업에 대한 세부 구현 가이드를 제시합니다.

1.1 generated/*.xml 파일 파싱하여 타입명 수집

파싱 서비스 클래스 추가: 파일 입출력 및 파싱 로직은 서비스 레이어에 구현하는 것이 좋습니다 (MVVM 원칙에 따라 UI 비의존 로직 분리). 예를 들어 Services/ConfigService.cs (또는 ConfigParser.cs) 같은 정적 클래스를 만들어 사용합니다.

/// <summary>config 디렉터리의 XML을 파싱하여 토픽 타입명과 QoS 프로필명을 로드</summary>
public static class ConfigService
{
    /// <summary>generated 폴더의 XML에서 타입 이름 목록 추출</summary>
    public static List<string> LoadTypeNames(string configRoot) { ... }

    /// <summary>qos 폴더의 XML에서 QoS 프로필 이름 목록 추출</summary>
    public static List<string> LoadQosProfiles(string configRoot) { ... }
}


위와 같이 한글 주석을 포함한 메서드 시그니처를 정의해 두면 됩니다.

LoadTypeNames 구현: configRoot 경로 아래 generated 디렉터리의 모든 XML 파일을 대상으로 타입명을 추출합니다.

파일 검색: Directory.GetFiles를 사용하여 generated 폴더의 모든 .xml 파일 경로를 가져옵니다. 예시:

string generatedDir = Path.Combine(configRoot, "generated");
foreach (string file in Directory.GetFiles(generatedDir, "*.xml"))
{
    // 각 file 경로에 대해 XML 파싱
}


만약 generated 폴더가 없거나 파일이 없다면, 빈 결과를 반환하고 로깅할 수 있습니다 (예: "No type definitions found in config/generated").

XML 파싱: 각 파일을 XDocument.Load(file) 등으로 로드하고, LINQ-to-XML을 사용하여 <struct> 요소들을 찾습니다.

네임스페이스 처리: <struct> 태그가 네임스페이스 없이 정의되었거나 특정 네임스페이스가 있을 수 있습니다. 편의를 위해 LocalName으로 비교하면 네임스페이스에 상관없이 태그를 찾을 수 있습니다.

필터 조건: <struct> 요소의 name 속성이 "C_"로 시작하는지 확인하여 해당 이름만 수집합니다.

XDocument doc = XDocument.Load(file);
var typeNamesInFile = doc.Descendants()  
    .Where(e => e.Name.LocalName == "struct")
    .Select(e => e.Attribute("name")?.Value)
    .Where(name => name != null && name.StartsWith("C_"));


수집 및 중복 처리: 발견된 타입명을 전역 리스트에 추가합니다. 여러 파일에 동일한 타입 정의가 중복되지 않는 한 일반적으로 중복은 없겠지만, HashSet 등을 이용해 중복을 걸러주면 안전합니다.

정렬(Optional): UI에서 보기 쉽게 알파벳순 정렬을 고려할 수 있습니다. 예를 들어 typeNamesList.Sort()를 호출합니다.

Topic 필드에 대한 처리: 선택된 타입명을 기반으로 Topic 기본값을 설정해주는 개선 C_ 접두를 뺀 나머지 값을 기본 topic 이름 값으로

1.2 qos/*.xml 파일 파싱하여 QoS 프로필명 수집

LoadQosProfiles 구현: configRoot 아래 qos 디렉터리의 모든 XML 파일에서 QoS 프로필 이름을 추출합니다. RTI Connext 형식의 예시처럼 <qos_library> 내에 여러 <qos_profile> 태그들이 있을 수 있습니다 (예: NGVA_QoS_Library 라이브러리 아래 control_low_latency_reliable 등의 프로필) – 사용자 제공 예시 참조.

파일 검색: Directory.GetFiles를 사용하여 qos 폴더의 .xml 파일들을 모두 나열합니다. (qos 폴더가 없거나 파일이 없으면 경고 로그 남기고 빈 리스트 반환).

XML 파싱: 각 파일을 XDocument로 로드한 후, 모든 <qos_profile> 요소를 찾아 프로필명을 수집합니다.

<qos_profile>도 네임스페이스가 있을 수 있으므로 e.Name.LocalName == "qos_profile" 방식으로 찾습니다.

라이브러리 이름 포함 여부: QoS 프로필은 라이브러리 이름과 프로필 이름을 함께 식별하는 것이 좋습니다. Connext의 경우 "라이브러리이름::프로필이름" 형식으로 사용하므로, 파싱 시 각 <qos_profile>의 상위 <qos_library name="...">의 이름을 함께 읽어와 LibraryName::ProfileName 형태로 저장합니다.

구현 예시: 먼저 <qos_library> 요소들을 탐색하면서, 해당 라이브러리 이름을 변수에 저장한 뒤 그 아래 존재하는 <qos_profile>들을 찾습니다.

XDocument doc = XDocument.Load(file);
foreach (var libElem in doc.Descendants().Where(e => e.Name.LocalName == "qos_library"))
{
    string libName = libElem.Attribute("name")?.Value ?? "";
    foreach (var profileElem in libElem.Descendants().Where(e => e.Name.LocalName == "qos_profile"))
    {
        string profileName = profileElem.Attribute("name")?.Value;
        if (!string.IsNullOrEmpty(profileName))
            profileList.Add($"{libName}::{profileName}");
    }
}


위 코드에서는 <qos_library>별로 순회하면서 내부의 모든 <qos_profile> name들을 "라이브러리::프로필" 형태로 리스트에 추가합니다. 만약 라이브러리 이름이 빈 경우 (없을 경우) "::프로필"처럼 처리될 수 있으니, 그런 경우에는 콜론을 빼는 등의 보완이 필요합니다.

중복 제거 및 정렬: 여러 파일에 동일한 프로필이 선언될 가능성은 낮지만, 마찬가지로 중복 체크를 수행하고 필요에 따라 정렬합니다.

기본 QoS 프로필 처리: QoS XML에 is_default_qos="true"로 지정된 프로필이 있을 수 있습니다. 지금 단계에서는 별도 처리하지 않고 목록만 채우지만, UI 초기값으로 기본 프로필을 선택하고 싶다면 is_default_qos="true" 속성을 확인하여 해당 프로필을 최우선 선택하는 로직을 추가할 수 있습니다 (필요 시 구현 단계에서 고려).

1.3 MainViewModel.ReloadConfig() 연동

ViewModel 수정: MainViewModel의 ReloadConfig 메서드에 위에서 만든 ConfigService 호출을 추가하여 실제 데이터를 로드합니다. 현재 ReloadConfig()는 TODO로 표시되어 있으며, 하드코드된 값들을 추가하고 있습니다
GitHub
. 이 부분을 다음과 같이 변경합니다.

private void ReloadConfig()
{
    try
    {
        // 기존 목록 초기화
        QosProfiles.Clear();
        TypeNames.Clear();

        // 새로운 목록 로드
        var profiles = ConfigService.LoadQosProfiles(_configRoot);
        foreach (var profile in profiles) QosProfiles.Add(profile);

        var types = ConfigService.LoadTypeNames(_configRoot);
        foreach (var type in types) TypeNames.Add(type);

        Log("Config reloaded");
    }
    catch (Exception ex)
    {
        Log($"Config load failed: {ex.Message}");
    }
}


예외 처리: 파일 접근이나 XML 파싱 중 예외가 발생할 가능성이 있으므로 try-catch로 감싸 오류를 잡고, Log 메서드를 통해 사용자에게 이해하기 쉬운 메시지를 전달합니다. (예: Log("Config load failed: ...")로 상태 표시). 서비스 메서드 내부에서도 필요한 경우 예외를 던지거나 처리하지만, ViewModel에서 한 번 더 예외를 잡아 로그를 남기는 이중 예외 처리를 권장합니다
GitHub
.

UI 바인딩 동작: ObservableCollection인 QosProfiles와 TypeNames를 Clear 후 Add로 채우면 UI의 ComboBox 바인딩이 자동 갱신됩니다. 별도로 SelectedQosProfile이나 SelectedType을 설정하지 않으면 현재 선택은 없어집니다. 필요하다면 초기 선택값을 지정할 수 있습니다. 예를 들어 첫 항목이 존재하면 SelectedQosProfile = QosProfiles.First() 등으로 설정 가능합니다.

토픽 필드 유지: Topic (_topic)은 Reload 시 변경하지 않고 그대로 둡니다. 사용자가 Config를 변경한 경우라도 이전에 입력한 토픽명이 남아있을 수 있는데, 만약 이를 초기화하고 싶다면 Topic = ""로 재설정할 수도 있습니다. 현재 요구상 특별한 지시가 없으므로 건드리지 않습니다.

동작 확인: 이렇게 구현하면 앱 실행 시 초기 ConfigRoot 경로에서 타입과 QoS 목록을 로드하고, 사용자가 Browse/Reload로 Config 디렉토리를 변경할 때마다 새로운 설정을 불러오게 됩니다
GitHub
GitHub
. ComboBox에 최신 목록이 채워지므로 사용자는 Type을 선택하고 Topic을 직접 입력하여 DDS 엔티티 생성 및 통신을 진행할 수 있습니다.

추가 참고: Config 경로 결정은 이미 ConfigLocator.Resolve에서 CLI 인자나 환경변수를 통해 처리되고 있으므로
GitHub
GitHub
, 그 값을 활용하면 됩니다. ReloadConfig()에서는 _configRoot(현재 설정 디렉토리)를 기반으로 위 로직을 수행하므로, 별도로 경로를 하드코딩하지 않도록 주의합니다. 또한, 1단계 구현이 완료되면 QoS 선택 ComboBox와 Type 선택 ComboBox에 실제 값들이 나타나고, Create Participant 등의 버튼을 눌렀을 때 로그에 사용자가 선택한 QoS와 타입이 반영된 메시지가 출력될 것입니다
GitHub
GitHub
.

이상으로 1단계 구현 가이드를 마칩니다. 이 단계를 완료함으로써 UI가 설정 파일에 연동되어 동적으로 타입/프로필을 표시하게 됩니다. 다음 단계에서는 이 토픽 타입에 대한 동적 폼 생성이나 샘플 JSON 채우기 등의 기능(6단계, 7단계에서 언급)이 구체화될 예정입니다. 현재 단계에서 구축한 파싱 로직은 이후 단계들의 기반이 되므로, 구현 시 정확한 동작을 확인하고 충분히 테스트해 두는 것을 권장합니다.